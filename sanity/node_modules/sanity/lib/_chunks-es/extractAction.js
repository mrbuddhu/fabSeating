import { writeFile } from "node:fs/promises";
import path, { dirname, join } from "node:path";
import { pathToFileURL, fileURLToPath } from "node:url";
import { Worker } from "node:worker_threads";
import readPkgUp from "read-pkg-up";
import { resolveConfig, SchemaError } from "sanity";
import fs from "node:fs";
import Module, { createRequire, register as register$1 } from "node:module";
import { firstValueFrom } from "rxjs";
import { ResizeObserver } from "@juggle/resize-observer";
import { register } from "esbuild-register/dist/node";
import jsdomGlobal from "jsdom-global";
import { addHook } from "pirates";
import resolveFrom from "resolve-from";
import { getStudioEnvironmentVariables } from "./cli.js";
import { defineTrace } from "@sanity/telemetry";
import { formatSchemaValidation } from "./formatSchemaValidation.js";
function getProxyHandler() {
  const handler = {
    get: (_target, prop) => prop === "__esModule" ? !0 : prop === "default" ? new Proxy({}, handler) : new Proxy({}, handler),
    apply: () => new Proxy({}, handler)
  };
  return new Proxy({}, handler);
}
function setupImportErrorHandler() {
  const ModuleConstructor = Module, originalLoad = ModuleConstructor._load;
  return ModuleConstructor._load = function(request, parent, isMain) {
    try {
      return originalLoad.call(this, request, parent, isMain);
    } catch (error) {
      if (request.startsWith("https://themer.sanity.build/api/"))
        return getProxyHandler();
      throw error;
    }
  }, {
    cleanup: () => {
      ModuleConstructor._load = originalLoad;
    }
  };
}
const require$2 = createRequire(import.meta.url);
register$1("./mock-browser-env-stub-loader.mjs", pathToFileURL(require$2.resolve("sanity/package.json")));
const jsdomDefaultHtml = `<!doctype html>
<html>
  <head><meta charset="utf-8"></head>
  <body></body>
</html>`;
function mockBrowserEnvironment(basePath) {
  if (global && global.window && "__mockedBySanity" in global.window)
    return () => {
    };
  const importErrorHandler = setupImportErrorHandler(), btoa = global.btoa, domCleanup = jsdomGlobal(jsdomDefaultHtml, {
    url: "http://localhost:3333/"
  });
  typeof btoa == "function" && (global.btoa = btoa);
  const windowCleanup = () => global.window.close(), globalCleanup = provideFakeGlobals(basePath), cleanupFileLoader = addHook((code, filename) => `module.exports = ${JSON.stringify(filename)}`, {
    ignoreNodeModules: !1,
    exts: getFileExtensions()
  }), {
    unregister: unregisterESBuild
  } = register({
    target: "node18",
    supported: {
      "dynamic-import": !0
    },
    format: "cjs",
    extensions: [".js", ".jsx", ".ts", ".tsx", ".mjs"],
    jsx: "automatic",
    define: {
      // define the `process.env` global
      ...getStudioEnvironmentVariables({
        prefix: "process.env.",
        jsonEncode: !0
      }),
      // define the `import.meta.env` global
      ...getStudioEnvironmentVariables({
        prefix: "import.meta.env.",
        jsonEncode: !0
      }),
      // define the `import.meta.hot` global, so we don't get `"import.meta" is not available with the "cjs" output format and will be empty` warnings
      "import.meta.hot": "false"
    }
  });
  return function() {
    unregisterESBuild(), cleanupFileLoader(), globalCleanup(), windowCleanup(), domCleanup(), importErrorHandler.cleanup();
  };
}
const getFakeGlobals = (basePath) => ({
  __mockedBySanity: !0,
  requestAnimationFrame: setImmediate,
  cancelAnimationFrame: clearImmediate,
  requestIdleCallback: setImmediate,
  cancelIdleCallback: clearImmediate,
  ace: tryGetAceGlobal(basePath),
  InputEvent: global.window?.InputEvent,
  customElements: global.window?.customElements,
  ResizeObserver: global.window?.ResizeObserver || ResizeObserver,
  matchMedia: global.window?.matchMedia || (() => ({
    matches: !1,
    media: "",
    onchange: null
  }))
}), getFakeDocumentProps = () => ({
  execCommand: function(_commandName, _showDefaultUI, _valueArgument) {
    return !1;
  }
});
function provideFakeGlobals(basePath) {
  const globalEnv = global, globalWindow = global.window, globalDocument = global.document || document || {}, fakeGlobals = getFakeGlobals(basePath), fakeDocumentProps = getFakeDocumentProps(), stubbedGlobalKeys = [], stubbedWindowKeys = [], stubbedDocumentKeys = [];
  for (const [rawKey, value] of Object.entries(fakeGlobals)) {
    if (typeof value > "u")
      continue;
    const key = rawKey;
    key in globalEnv || (globalEnv[key] = fakeGlobals[key], stubbedGlobalKeys.push(key)), key in global.window || (globalWindow[key] = fakeGlobals[key], stubbedWindowKeys.push(key));
  }
  for (const [rawKey, value] of Object.entries(fakeDocumentProps)) {
    if (typeof value > "u")
      continue;
    const key = rawKey;
    key in globalDocument || (globalDocument[key] = fakeDocumentProps[key], stubbedDocumentKeys.push(key));
  }
  return () => {
    stubbedGlobalKeys.forEach((key) => {
      delete globalEnv[key];
    }), stubbedWindowKeys.forEach((key) => {
      delete globalWindow[key];
    }), stubbedDocumentKeys.forEach((key) => {
      delete globalDocument[key];
    });
  };
}
function tryGetAceGlobal(basePath) {
  const acePath = resolveFrom.silent(basePath, "ace-builds");
  if (acePath)
    try {
      return require$2(acePath);
    } catch {
      return;
    }
}
function getFileExtensions() {
  return [".css", ".eot", ".gif", ".jpeg", ".jpg", ".otf", ".png", ".sass", ".scss", ".svg", ".ttf", ".webp", ".woff", ".woff2"];
}
const require$1 = createRequire(import.meta.url), candidates = ["sanity.config.js", "sanity.config.jsx", "sanity.config.ts", "sanity.config.tsx"];
function getStudioConfig({
  basePath,
  configPath: cfgPath
}) {
  let cleanup;
  try {
    cleanup = mockBrowserEnvironment(basePath);
    let configPath = cfgPath;
    if (configPath && !fs.existsSync(configPath))
      throw new Error(`Failed to find config at "${cfgPath}"`);
    if (configPath || (configPath = candidates.map((candidate) => path.join(basePath, candidate)).find((candidate) => fs.existsSync(candidate))), !configPath)
      throw new Error(`Failed to resolve sanity.config.(js|ts) for base path "${basePath}"`);
    let config;
    try {
      const mod = require$1(configPath);
      config = mod.__esModule && mod.default ? mod.default : mod;
    } catch (err) {
      throw new Error(`Failed to load configuration file "${configPath}"`, {
        cause: err
      });
    }
    if (!config) throw new Error("Configuration did not export expected config shape");
    return Array.isArray(config) ? config : [{
      ...config,
      name: config.name || "default",
      basePath: config.basePath || "/"
    }];
  } finally {
    cleanup?.();
  }
}
async function getStudioWorkspaces(options) {
  let cleanup;
  try {
    cleanup = mockBrowserEnvironment(options.basePath);
    const config = getStudioConfig(options), workspaces = await firstValueFrom(resolveConfig(config));
    if (!workspaces) throw new Error("Failed to resolve configuration");
    return workspaces;
  } finally {
    cleanup?.();
  }
}
const SchemaExtractedTrace = defineTrace({
  name: "Schema Extracted",
  version: 0,
  description: "Trace emitted when extracting schema"
}), __dirname$1 = dirname(fileURLToPath(import.meta.url));
async function extractAction(args, {
  workDir,
  output,
  telemetry
}) {
  const flags = args.extOptions, formatFlag = flags.format || "groq-type-nodes", enforceRequiredFields = flags["enforce-required-fields"] || !1, rootPkgPath = readPkgUp.sync({
    cwd: __dirname$1
  })?.path;
  if (!rootPkgPath)
    throw new Error("Could not find root directory for `sanity` package");
  const workerPath = join(dirname(rootPkgPath), "lib", "_internal", "cli", "threads", "extractSchema.cjs"), spinner = output.spinner({}).start(enforceRequiredFields ? "Extracting schema, with enforced required fields" : "Extracting schema"), trace = telemetry.trace(SchemaExtractedTrace);
  trace.start();
  const worker = new Worker(workerPath, {
    workerData: {
      workDir,
      workspaceName: flags.workspace,
      enforceRequiredFields,
      format: formatFlag
    },
    env: process.env
  });
  try {
    const {
      schema
    } = await new Promise((resolve, reject) => {
      worker.addListener("message", resolve), worker.addListener("error", reject);
    });
    trace.log({
      schemaAllTypesCount: schema.length,
      schemaDocumentTypesCount: schema.filter((type) => type.type === "document").length,
      schemaTypesCount: schema.filter((type) => type.type === "type").length,
      enforceRequiredFields,
      schemaFormat: formatFlag
    });
    const path2 = flags.path || join(process.cwd(), "schema.json");
    spinner.text = `Writing schema to ${path2}`, await writeFile(path2, `${JSON.stringify(schema, null, 2)}
`), trace.complete(), spinner.succeed(enforceRequiredFields ? `Extracted schema to ${path2} with enforced required fields` : `Extracted schema to ${path2}`);
  } catch (err) {
    if (trace.error(err), spinner.fail(enforceRequiredFields ? "Failed to extract schema, with enforced required fields" : "Failed to extract schema"), isSchemaError(err))
      try {
        await getStudioWorkspaces({
          basePath: workDir
        });
      } catch (innerErr) {
        const validation = extractValidationFromCoreSchemaError(innerErr);
        throw validation && validation.length > 0 && (output.print(""), output.print(formatSchemaValidation(validation))), err;
      }
    throw err;
  }
}
function isValidationProblemGroup(item) {
  if (typeof item != "object" || item === null)
    return !1;
  const group = item;
  return Array.isArray(group.path) && Array.isArray(group.problems);
}
function extractValidationFromCoreSchemaError(error) {
  if (!(error instanceof SchemaError))
    return null;
  const schema = error.schema;
  if (!schema || typeof schema != "object")
    return null;
  const validation = schema._validation;
  return !Array.isArray(validation) || !validation.every(isValidationProblemGroup) ? null : validation;
}
function isSchemaError(err) {
  if (typeof err != "object" || err === null)
    return !1;
  const errorLike = err, hasSchemaErrorName = errorLike.name === "SchemaError", hasSchemaErrorMessage = errorLike.message === "SchemaError";
  return hasSchemaErrorName || hasSchemaErrorMessage;
}
export {
  extractAction as default
};
//# sourceMappingURL=extractAction.js.map
